// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/Elevator.h"
#include "Commands/TeleopElevator.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "Commands/TeleopElevator.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

/**
 * @brief Construct a new Elevator:: Elevator object
 * 
 * 1. Get useful parameters from SmartDashboard
 *      a. PID gains for inner, outer, and rear elevators
 *      b. Get min/max positions for inner, outer, and rear elevators 
 *      c. Get predefined positions for Level 1-3 hatch and cargo
 *      d. Get predefined positions for hatch/cargo lift[] and release
 * 2. Initialize inner elevator (talon motor controller)
 *      2a. Gains, sensors, sensor positions, and magic motion variables
 * 3. Initialize rear elevator (talon motor controller)
 *      3a. Gains, sensors, sensor positions, and magic motion variables
 * 4. Initialize outer elevator (CAN Spark Max Brushless motor controller)
 *      4a. Gains, sensors, sensor positions, and magic motion variables
 
 */
Elevator::Elevator() : frc::Subsystem("Elevator"),
    kP_Inner(frc::Preferences::GetInstance()->GetDouble("kP Inner", 6.0)),
    kD_Inner(frc::Preferences::GetInstance()->GetDouble("kD Inner", 600.0)),
    kI_Inner(frc::Preferences::GetInstance()->GetDouble("kI Inner", 0.0)),
    kF_Inner(frc::Preferences::GetInstance()->GetDouble("kF Inner", 0.0)),
    kP_Outer(frc::Preferences::GetInstance()->GetDouble("kP Outer", 0.3)),
    kD_Outer(frc::Preferences::GetInstance()->GetDouble("kD Outer", 1.0)),
    kI_Outer(frc::Preferences::GetInstance()->GetDouble("kI Outer", 0.0)),
    kF_Outer(frc::Preferences::GetInstance()->GetDouble("kF Outer", 0.0)),
    kP_Rear(frc::Preferences::GetInstance()->GetDouble("kP Rear", 0.0)),
    kD_Rear(frc::Preferences::GetInstance()->GetDouble("kD Rear", 0.0)),
    kI_Rear(frc::Preferences::GetInstance()->GetDouble("kI Rear", 0.0)),
    kF_Rear(frc::Preferences::GetInstance()->GetDouble("kF Rear", 0.0)),
    bMagic(frc::Preferences::GetInstance()->GetBoolean("Magic Elevator", false)),
    kMaxInnerPos(frc::Preferences::GetInstance()->GetDouble("Max Inner", 38.5)),
    kMinInnerPos(frc::Preferences::GetInstance()->GetDouble("Min Inner", 0.0)),
    kMaxOuterPos(frc::Preferences::GetInstance()->GetDouble("Max Outer", 38.5)),
    kMinOuterPos(frc::Preferences::GetInstance()->GetDouble("Min Outer", -20.0)),
    kMaxRearPos(frc::Preferences::GetInstance()->GetDouble("Max Rear", 0.0)),
    kMinRearPos(frc::Preferences::GetInstance()->GetDouble("Min Rear", -20.0)),
    kHatchL1(frc::Preferences::GetInstance()->GetDouble("Hatch L1", 9.0)),
    kHatchL2(frc::Preferences::GetInstance()->GetDouble("Hatch L2", 38.0)),
    kHatchL3(frc::Preferences::GetInstance()->GetDouble("Hatch L3", 34.0)),
    kCargoL1(frc::Preferences::GetInstance()->GetDouble("Cargo L1", 20.0)),
    kCargoL2(frc::Preferences::GetInstance()->GetDouble("Cargo L2", 13.0)),
    kCargoL3(frc::Preferences::GetInstance()->GetDouble("Cargo L3", 38.0)),
    kRearLiftPos(frc::Preferences::GetInstance()->GetDouble("Rear Lift Pos", -15.0)),
    kFwdLiftPos(frc::Preferences::GetInstance()->GetDouble("Fwd Lift Pos", -15.0)),
    kHatchReleasePos(frc::Preferences::GetInstance()->GetDouble("Hatch Release", 3.0)) {

    // Both robots have "inner elevator"
    talonInnerFront.reset(new WPI_TalonSRX(9));
    talonInnerFront->ConfigSelectedFeedbackSensor(FeedbackDevice::QuadEncoder, 0, 0);
    talonInnerFront->ConfigReverseLimitSwitchSource(LimitSwitchSource::LimitSwitchSource_FeedbackConnector, LimitSwitchNormal::LimitSwitchNormal_NormallyOpen, 0);
    if (Robot::IsPracticeBot()) {
        talonInnerFront->SetInverted(true);
    }
    talonInnerFront->SetSensorPhase(false);
    talonInnerFront->SetSelectedSensorPosition(0, 0);
    talonInnerFront->Config_kP(0, kP_Inner);
    talonInnerFront->Config_kI(0, kI_Inner);
    talonInnerFront->Config_kD(0, kD_Inner);
    talonInnerFront->Config_kF(0, kF_Inner);
    talonInnerFront->ConfigMotionAcceleration(INNER_MAGIC_ACCEL);      // cnts/100 msec
    talonInnerFront->ConfigMotionCruiseVelocity(INNER_MAGIC_VELOCITY); // cnts/100 msec
//    talonInnerFront->ConfigClosedloopRamp(0.3);     // 0.3 seconds to full speed

    if (Robot::IsPracticeBot())
    {
        printf("Practice Elevator\n");
    }
    else
    {
        limitSwitchInnerTop.reset(new frc::DigitalInput(0));
        AddChild("Limit Switch Inner Top", limitSwitchInnerTop);

        limitSwitchInnerBottom.reset(new frc::DigitalInput(1));
        AddChild("Limit Switch Inner Bottom", limitSwitchInnerBottom);


        talonRear.reset(new WPI_TalonSRX(8));
        talonRear->ConfigSelectedFeedbackSensor(FeedbackDevice::QuadEncoder, 0, 0);
        talonRear->SetSensorPhase(true);
        talonRear->SetSelectedSensorPosition(0, 0);
        talonRear->Config_kP(0, kP_Rear);
        talonRear->Config_kI(0, kI_Rear);
        talonRear->Config_kD(0, kD_Rear);
        talonRear->Config_kF(0, kF_Rear);
        talonRear->ConfigMotionAcceleration(REAR_MAGIC_ACCEL);      // cnts/100 msec
        talonRear->ConfigMotionCruiseVelocity(REAR_MAGIC_VELOCITY); // cnts/100 msec

        sparkMaxOuter.reset(new rev::CANSparkMax(sparkElevatorID, rev::CANSparkMax::MotorType::kBrushless));
        pidOuter.reset(new rev::CANPIDController(sparkMaxOuter->GetPIDController()));
        sparkMaxOuterEncoder.reset(new rev::CANEncoder(sparkMaxOuter->GetEncoder()));

        // set scaling factor for position (since encoder is in motor)
        sparkMaxOuterEncoder->SetPositionConversionFactor((OUTER_SPROCKET_PITCH * M_PI) / OUTER_GEAR_RATIO);
        sparkMaxOuterEncoder->SetVelocityConversionFactor((OUTER_SPROCKET_PITCH * M_PI) / OUTER_GEAR_RATIO / 60.0);

        sparkMaxOuterEncoder->SetPosition(0.0);

        // Config PID gains for Spark Max Outer
        sparkMaxOuter->SetClosedLoopRampRate(0.3); // 0.3 seconds to ramp to full speed
        pidOuter->SetOutputRange(kMinOutput, kMaxOutput);
        pidOuter->SetP(kP_Outer);
        pidOuter->SetI(kI_Outer);
        pidOuter->SetD(kD_Outer);
        pidOuter->SetFF(kF_Outer);

        pidOuter->SetSmartMotionMaxVelocity(OUTER_MAGIC_VELOCITY);
        pidOuter->SetSmartMotionMaxAccel(OUTER_MAGIC_ACCEL);
    }
}

/**
 * @brief Set the default command for Elevator Subsystem
 * 
 * This command is the TeleopElevator command
 * 
 */
void Elevator::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new TeleopElevator());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

/**
 * @brief Code to be periodically run in Elevator class
 * 
 * Constantly update the inner and outer positions of the elevator
 * on the SmartDashboard.
 */
void Elevator::Periodic() {
    // Put code here to be run every loop
    ControlElevatorPositions();

    // put elevator positions on smartdash
    frc::SmartDashboard::PutNumber("Elevator Setpoint Inner (inches)", mInnerPosCmd);
    frc::SmartDashboard::PutNumber("Elevator Setpoint Outer (inches)", mOuterPosCmd);
    frc::SmartDashboard::PutNumber("Elevator Setpoint Rear (inches)", mRearPosCmd);
}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

/**
 * @brief Main function that set ALL elevator positions
 * 
 * May utilize the magic motion variable 
 * (for more controlled accel and decel)
 */
void Elevator::ControlElevatorPositions() {
    if (Robot::IsPracticeBot()) {
        ControlInnerPosition(bMagic);
    }
    else {
        ControlInnerPosition(bMagic);
        ControlOuterPosition(bMagic);
        ControlRearPosition();
    }
}

/**
 * @brief Set inner elevator positions
 * 
 * Also update positions on SmartDashboard
 * 
 * @param bMagic 
 */
void Elevator::ControlInnerPosition(bool bMagic) {
    // calculate in inches and convert to native counts for command setpoint
    mInnerPosCmd = fmax(mInnerPosCmd, kMinInnerPos);
    mInnerPosCmd = fmin(mInnerPosCmd, kMaxInnerPos);
    if (bMagic) {
        talonInnerFront->Set(ControlMode::MotionMagic, inchesToCountsInner(mInnerPosCmd));
    }
    else {    //Step input
        talonInnerFront->Set(ControlMode::Position, inchesToCountsInner(mInnerPosCmd));
    }
    frc::SmartDashboard::PutNumber("Inner Elevator", GetInnerPosInches());
    frc::SmartDashboard::PutNumber("Inner Elevator Cnts", GetInnerPos());
}

/**
 * @brief Set outer elevator positions
 * 
 * Also update positions on SmartDashboard
 * 
 * @param bMagic 
 */
void Elevator::ControlOuterPosition(bool bMagic) {
    // calculate in inches and command in inches thanks to position scaling
    pidOuter->SetReference(mOuterPosCmd, rev::ControlType::kPosition);
    frc::SmartDashboard::PutNumber("Outer Elevator", GetOuterPosInches());
}

/**
 * @brief Set rear elevator positions
 * 
 * Also update positions on SmartDashboard
 * 
 * @param bMagic 
 */
void Elevator::ControlRearPosition() {
    // calculate in inches and convert to native encoder units for setpoint
    talonRear->Set(ControlMode::Position, inchesToCountsRear(mRearPosCmd));
    frc::SmartDashboard::PutNumber("Rear Elevator", GetRearPosInches());
}

/**
 * @brief Determines if the inner elevator is at its desired position
 * 
 * Since position is never 100% accurate, this function returns true
 * if the position is within IN_POSITION_DEADBAND in from the desired position.
 * 
 * @return true 
 * @return false 
 */
bool Elevator::InnerAtPosition() {
    bool atPositionWithDeadband = false;

    if (std::fabs(mInnerPosCmd - GetInnerPosInches()) < IN_POSITION_DEADBAND) {
        atPositionWithDeadband = true;
    }

    return atPositionWithDeadband;
}

/**
 * @brief Determines if the outer elevator is at its desired position
 * 
 * Since position is never 100% accurate, this function returns true
 * if the position is within IN_POSITION_DEADBAND in from the desired position.
 * 
 * @return true 
 * @return false 
 */
bool Elevator::OuterAtPosition() {
    bool atPositionWithDeadband = false;

    // we will fix this later (sorry gang)
    if (std::fabs(mOuterPosCmd + GetOuterPosInches()) < IN_POSITION_DEADBAND) {
        atPositionWithDeadband = true;
    }
    
    return atPositionWithDeadband;
}

/**
 * @brief Determines if the outer elevator is at its desired position
 * 
 * Since position is never 100% accurate, this function returns true
 * if the position is within IN_POSITION_DEADBAND in from the desired position.
 * 
 * @return true 
 * @return false 
 */
bool Elevator::RearAtPosition() {
    bool atPositionWithDeadband = false;

    if (std::fabs(mRearPosCmd - GetRearPosInches()) < IN_POSITION_DEADBAND) {
        atPositionWithDeadband = true;
    }
    
    return atPositionWithDeadband;
}

/**
 * @brief Stop all elevators by setting their desired position to their current positions
 */
void Elevator::StopAllElevators() {
    StopInner();
    if (!Robot::IsPracticeBot()) {
        StopOuter();
        StopRear();
    }
}

/**
 * @brief Stops the inner elevator by setting its desired position to its current position
 */
void Elevator::StopInner() {
    mInnerPosCmd = GetInnerPosInches();
    talonInnerFront->Set(ControlMode::MotionMagic, inchesToCountsInner(mInnerPosCmd));
}

/**
 * @brief Stops the rear elevator by setting its desired position to its current position
 */
void Elevator::StopRear() {
    mRearPosCmd = GetRearPosInches();
}

/**
 * @brief Stops the outer elevator by setting its desired position to its current position
 */
void Elevator::StopOuter() {
    mOuterPosCmd = GetOuterPosInches();
}

/**
 * @brief Helper method that converts inner elevator position to rotations
 * 
 * @param inches 
 * @return rotations 
 */
double Elevator::inchesToRotationsOuter(double inches){
    return inches / OUTER_SPROCKET_PITCH * OUTER_GEAR_RATIO;
}

/**
 * @brief Helper method that converts inner elevator rotations to inches
 * 
 * @param rotations 
 * @return inches 
 */
double Elevator::rotationsToInchesOuter(double rotations) {
    return rotations * OUTER_SPROCKET_PITCH * M_PI;
}

/**
 * @brief Return the position of the inner elevator in inches
 * 
 * @return position 
 */
double Elevator::GetInnerPosInches() {
    return countsToInchesInner(GetInnerPos());
}

/**
 * @brief Return the position of the rear elevator in inches
 * 
 * @return position 
 */
double Elevator::GetRearPosInches() {
    return countsToInchesRear(GetRearPos());
}

/**
 * @brief Return the position of the outer elevator in inches
 * 
 * @return position 
 */
double Elevator::GetOuterPosInches() {
    return -GetOuterPos();   // No need for math here because we have the scale factor
}

/**
 * @brief Helper method that converts inner elevator position [in] to encoder counts
 * 
 * @param inches 
 * @return encoder_counts 
 */
double Elevator::inchesToCountsInner(double inches) {
    return (inches / (INNER_SPROCKET_PITCH * M_PI) * ENCODER_CNTS_PER_REV);
}

/**
 * @brief Helper method that converts inner elevator position [encoder counts] to inches
 * 
 * @param counts 
 * @return inches
 */
double Elevator::countsToInchesInner(double counts) {
    return (counts / ENCODER_CNTS_PER_REV * (INNER_SPROCKET_PITCH * M_PI));
}

/**
 * @brief Helper method that converts rear elevator position [in] to encoder counts
 * 
 * @param inches 
 * @return encoder_counts 
 */
double Elevator::inchesToCountsRear(double inches) {
    return (inches / (REAR_INCHES_PER_ROTAION) * ENCODER_CNTS_PER_REV);
}

/**
 * @brief Helper method that converts rear elevator position [encoder counts] to inches
 * 
 * @param counts 
 * @return inches
 */
double Elevator::countsToInchesRear(double counts) {
    return (counts / ENCODER_CNTS_PER_REV * (REAR_INCHES_PER_ROTAION));
}

/**
 * @brief Move the inner elevator up/down slew inches
 * 
 * @param slew 
 */
void Elevator::SlewInner(double slew) {
    double cmd = slew;
    bool stop = false;

    if (fabs(cmd) < 0.1) {
        cmd = 0.0;
        stop = true;
    } 
    cmd *= 20.0 * 0.02;
    if (stop) {
        if (!InnerAtPosition()) {
            StopInner();
        }
    }
    else {
        SetInnerPosition(Robot::elevator->GetInnerCmd() + cmd);
    }
}

/**
 * @brief Move the outer elevator up/down slew inches
 * 
 * @param slew 
 */
void Elevator::SlewOuter(double slew) {
    double cmd = slew;
    bool stop = false;

    if (fabs(cmd) < 0.2) {
        cmd = 0.0;
        stop = true;
    } 
    cmd *= 20.0 * 0.02;

    if (stop) {
        if (!OuterAtPosition()) {
            StopOuter();
        }
    }
    else {
        SetOuterPosition(Robot::elevator->GetOuterPosInches() + cmd);
    }
}

/**
 * @brief This method allows the zero positions of the elevators
 * to be updated while the robot is disabled.
 * 
 */
void Elevator::UpdateDisabledElevators() {
    mInnerPosCmd = GetInnerPos();
    if (mInnerPosCmd < 0.0) {
        talonInnerFront->SetSelectedSensorPosition(0, 0);
        mInnerPosCmd = 0.0;
    }
}

void Elevator::RigForClimb() {
   talonInnerFront->ConfigMotionCruiseVelocity(INNER_MAGIC_VELOCITY / 4.0);
   talonInnerFront->ConfigMotionAcceleration(INNER_MAGIC_ACCEL / 4.0);
   pidOuter->SetOutputRange(0.5 * kMinOutput, 0.5 * kMaxOutput);
}